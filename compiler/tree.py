import ast
import re
import typing

from py.compileunit import CompilationUnit

class ParseTreesData:
    __slots__ = ('_src_tree', '_ir_tree', '_py_tree')
    _src_tree: typing.Optional[CompilationUnit]    # The syntax tree generated by the parser.Parser
                                           #   from fluorite sources
    _ir_tree: typing.Optional[ast.AST]     # '_src_tree' transformed by codetransform.IRTransformer

    _py_tree: typing.Optional[ast.Module]  # The final syntax tree generated from '_ir_tree',
                                           #   representing a valid Python program coresponding
                                           #   to the input source

    def __init__(self):
        self._src_tree = None
        self._ir_tree = None
        self._py_tree = None

    @property
    def source_tree(self) -> CompilationUnit:
        assert self._src_tree is not None, 'attempted to get tree from empty ParseTreesData!'

        return typing.cast(CompilationUnit, self._src_tree)

    @source_tree.setter
    def source_tree(self, nodes: typing.Iterable[ast.stmt]):
        self._src_tree = CompilationUnit(body=list(nodes))

    def _unparse_source_tree(self):
        assert self._src_tree is not None

        src = ast.unparse(self._src_tree.ast_mod)
        src = src.strip()

        fold_newlines = re.compile(r"\n{2,}", re.MULTILINE|re.DOTALL)

        return re.sub(fold_newlines, "\n", src)

    def _dump_source_tree(self):
        assert self._src_tree is not None

        return ast.dump(self._src_tree,
                        annotate_fields=False, include_attributes=False, indent=2)
